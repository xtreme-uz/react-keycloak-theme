{"version":3,"file":"static/js/416.882d75b1.chunk.js","mappings":"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","sources":["../node_modules/evt/src/hooks/index.ts","../node_modules/evt/src/hooks/useEvt.ts","../node_modules/evt/src/hooks/useRerenderOnStateChange.ts","../node_modules/evt/src/lib/Evt.asNonPostable.ts","../node_modules/evt/src/lib/Evt.asPostable.ts","../node_modules/evt/src/lib/Evt.asyncPipe.ts","../node_modules/evt/src/lib/Evt.create.ts","../node_modules/evt/src/lib/Evt.factorize.ts","../node_modules/evt/src/lib/Evt.from.ts","../node_modules/evt/src/lib/Evt.getCtx.ts","../node_modules/evt/src/lib/Evt.ts","../node_modules/evt/src/lib/Evt.loosenType.ts","../node_modules/evt/src/lib/Evt.merge.ts","../node_modules/evt/src/lib/Evt.newCtx.ts","../node_modules/evt/src/lib/Evt.parsePropsFromArgs.ts","../node_modules/evt/src/lib/LazyEvt.ts","../node_modules/evt/src/lib/importProxy.ts","../node_modules/evt/src/lib/types/EventTargetLike.ts","../node_modules/evt/src/lib/types/EvtError.ts","../node_modules/evt/src/lib/types/interfaces/CtxLike.ts","../node_modules/evt/src/lib/util/compose.ts","../node_modules/evt/src/lib/util/convertOperatorToStatelessFLambda.ts","../node_modules/evt/node_modules/tsafe/src/assert.ts","../node_modules/evt/node_modules/tsafe/src/id.ts","../node_modules/evt/node_modules/tsafe/src/is.ts","../node_modules/evt/node_modules/tsafe/src/isPromiseLike.ts","../node_modules/evt/node_modules/tsafe/src/lab/overwriteReadonlyProp.ts","../node_modules/evt/node_modules/tsafe/src/typeGuard.ts","../node_modules/evt/node_modules/tsafe/src/zz_internal/assertIsRefWrapper.ts","../node_modules/evt/src/tools/Deferred.ts","../node_modules/evt/src/tools/safeSetTimeout.ts","../node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js","../node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js"],"sourcesContent":["/*\nNOTE: In theory react should be a peer dependency\ninstead of a dev dependency.\nBut given that /hook is just a plugin for using Evt\nwith react we don't want to require react to be\ninstalled to install Evt.\n*/\nexport { useEvt } from \"./useEvt\";\nexport { useRerenderOnStateChange } from \"./useRerenderOnStateChange\";","import { Evt } from \"../lib/Evt\";\nimport type { Ctx } from \"../lib\";\nimport * as React from \"react\";\nconst { useEffect } = React;\n\n\n/**\n * https://docs.evt.land/api/react-hooks\n * \n * Provide a Ctx to attach handlers.\n * You should list in deps all the Evt that are\n * susceptible to change ( Evt passed as props \n * or Evt that are react states ) that you use in the\n * factoryOrEffect callback. \n * As for useEffect you should also list every other\n * value that you use.\n * Whenever any value in deps is changed factoryOrEffect\n * is invoked again with the new Evt and the previous handler\n * get detached.\n * All handler are also detached when the component unmount.\n * \n * factoryOrEffect can be used for attaching handler to event\n * or to generate a new event that is a merge/pipe of other \n * Evts.\n * \n * BE AWARE: Unlike useEffect factoryOrEffect is called \n * on render ( like useMemo's callback ).\n * Remember that you shouldn't update state in a component \n * render tick (in the useMemo for example). If you you need to \n * perform an effect on first render (attaching a stateful evt\n * for example) use registerSideEffect(()=>{ ... })\n * \n * Demo: https://docs.evt.land/react-hooks#useevt\n */\nexport function useEvt(\n    effect: (ctx: Ctx) => void,\n    deps?: React.DependencyList\n): void {\n\n    useEffect(\n        ()=> {\n            const ctx= Evt.newCtx();\n\n            effect(ctx);\n\n            return ()=> { ctx.done(); };\n        },\n        deps\n    );\n\n}\n","import { useEvt } from \"./useEvt\";\nimport * as React from \"react\";\nconst { useState } = React;\n\ntype CtxLike<Result = any> = import(\"../lib/types/interfaces/CtxLike\").CtxLike<Result>;\n\ninterface StatefulReadonlyEvtLike {\n    state: unknown;\n    attach: (ctx: CtxLike, cb: (state: unknown)=> void)=> void;\n};\n\n/**\n * https://docs.evt.land/react-hooks#usererenderonstatechange\n * \n * To use StatefulEvt as react component state.\n * */\nexport function useRerenderOnStateChange(evt: StatefulReadonlyEvtLike): void {\n\n    //NOTE: We use function in case the state is a function\n    const [, setState] = useState(() => evt.state);\n\n    useEvt(\n        ctx =>\n            evt.attach(ctx, state => setState(() => state)),\n        [evt]\n    );\n}\n","\nimport type { ToNonPostableEvt, NonPostableEvtLike } from \"./types\";\n\n/** https://docs.evt.land/api/evt/asnonpostable */\nexport function asNonPostable<E extends NonPostableEvtLike<any>>(evt: E): ToNonPostableEvt<E>{\n    return evt as any;\n}","import type { NonPostableEvtLike, ToPostableEvt } from \"./types\";\n\n/** \n * @deprecated: ⚠ UNSAFE ⚠ - Please don't use it, it will be removed in the next \n * major release.\n * https://docs.evt.land/api/evt/aspostable \n * */\nexport function asPostable<E extends NonPostableEvtLike<any>>(evt: E): ToPostableEvt<E>{\n    return evt as any;\n}\n\n","\nimport type { Evt } from \"./Evt\";\nimport type { StatefulEvt, UnpackEvt, NonPostableEvtLike, StatefulReadonlyEvtLike } from \"./types\";\nimport type { PromiseOrNot } from \"tsafe/lab/PromiseOrNot\";\nimport { importProxy } from \"./importProxy\";\n\n\n\n/** \n * NOTE: Workaround until v2.0 where .pipe() will support async operators \n * Usage example: https://stackblitz.com/edit/evt-async-op?file=index.ts \n * \n * When the argument is a StatefulEvt:\n * If, wile asyncOp was running, the state of the source evt\n * have changed then the result will be discarded.\n * \n * If the asyncOp complete synchronously (meaning it does not return\n * a promise) then the result is synchronously transformed. (As with .pipe() )\n * \n * More usage example in src/test/test95.ts\n */\nexport function asyncPipe<E extends NonPostableEvtLike<any>, U>(\n    evt: E,\n    asyncOp: (data: UnpackEvt<E>) => PromiseOrNot<[U] | null>\n): \n    E extends StatefulReadonlyEvtLike<any> ? StatefulEvt<U | undefined> : Evt<U> \n{\n\n    const out = \"state\" in evt ?\n        importProxy.Evt.create<UnpackEvt<E> | undefined>(undefined) :\n        importProxy.Evt.create<UnpackEvt<E>>();\n\n    let currentCallCount = 0;\n\n    evt.attach(async (data: UnpackEvt<E>) => {\n\n        currentCallCount++;\n\n        const thisCallCount = currentCallCount;\n\n        const prOpResult = asyncOp(data);\n\n        let opResult: [U] | null;\n\n        if (\n            prOpResult !== null &&\n            \"then\" in prOpResult\n        ) {\n\n            opResult = await prOpResult;\n\n            if (\n                \"state\" in evt &&\n                thisCallCount !== currentCallCount\n            ) {\n                return;\n            }\n\n        } else {\n\n            opResult = prOpResult;\n\n        }\n\n        if (!opResult) {\n\n            return;\n        }\n\n        out.post(opResult[0] as any);\n\n    });\n\n    return out as any;\n\n}\n\n","\nimport { importProxy } from \"./importProxy\";\nimport type { Evt, StatefulEvt, NonPostableEvtLike, UnpackEvt } from \"./types\";\n\nexport function create<E extends NonPostableEvtLike<any> | undefined = NonPostableEvtLike<void>>(): Evt<UnpackEvt<E>>;\n/** \n * https://docs.evt.land/api/evt/create\n * Return a new Evt<T> instance.\n */\nexport function create<T>(): Evt<T>;\n/** \n * https://docs.evt.land/api/evt/create\n * Return a new StatefulEvt<T> instance.\n */\nexport function create<T>(initialState: T ): StatefulEvt<T>;\nexport function create<E extends NonPostableEvtLike<any> | undefined>(initialState: UnpackEvt<E> ): StatefulEvt<UnpackEvt<E>>;\nexport function create(...args: [] | [any] ): Evt<any> | StatefulEvt<any> {\n    return args.length === 0 ? \n        new importProxy.Evt() : \n        new importProxy.StatefulEvt(args[0])\n        ;\n}","import type { FactorizeEvt, NonPostableEvtLike } from \"./types\";\n\n/** https://docs.evt.land/api/evt/factorize */\nexport function factorize<E extends NonPostableEvtLike<any>>(\n    evt: E\n): FactorizeEvt<E> {\n    return evt as any;\n}\n\n/*\nimport { Evt } from \"./Evt\";\nconst x: Evt<boolean> = loosenType(new Evt<true>()); x;\nconst y: Evt<boolean> = loosenType(new Evt<number>()); y;\n*/","import { id } from \"tsafe/id\";\nimport { assert } from \"tsafe/assert\";;\nimport { typeGuard } from \"tsafe/typeGuard\";\nimport { mergeImpl } from \"./Evt.merge\";\nimport { importProxy } from \"./importProxy\";\nimport type { dom, Evt, NonPostableEvtLike } from \"./types\";\nimport type { EventTargetLike } from \"./types\";\nimport * as nsEventTargetLike from \"./types/EventTargetLike\";\nconst { EventTargetLike: EventTargetLikeAsValue } = nsEventTargetLike;\nimport type { ObserverConstructor } from \"./types/Observer\";\n\ntype OneOrMany<T> = T | ArrayLike<T>;\ntype CtxLike<Result> = import(\"./types\").CtxLike<Result> & {\n    evtDoneOrAborted: NonPostableEvtLike<unknown> & { postCount: number; attachOnce(callback: () => void): void; };\n};\n\nfunction fromImplForTargetEventLike<T>(\n    ctx: CtxLike<any> | undefined,\n    target: OneOrMany<EventTargetLike<T>> | PromiseLike<T>,\n    eventName?: string,\n    options?: EventTargetLike.HasEventTargetAddRemove.Options\n): Evt<T> {\n\n    const matchEventTargetLike =\n        (target_: typeof target): target_ is EventTargetLike<T> =>\n            EventTargetLikeAsValue.canBe(target_);\n\n    if (!matchEventTargetLike(target)) {\n\n        if (\"then\" in target) {\n\n            const evt = new importProxy.Evt<T>();\n\n            const isCtxDone = (() => {\n\n                const getEvtDonePostCount = () => ctx?.evtDoneOrAborted.postCount;\n\n                const n = getEvtDonePostCount();\n\n                return () => n !== getEvtDonePostCount();\n\n            })();\n\n            target.then(data => {\n\n                if (isCtxDone()) {\n                    return;\n                }\n\n                evt.post(data);\n\n            });\n\n            return evt;\n\n        }\n\n        return mergeImpl<Evt<T>>(\n            ctx,\n            Array.from(target).map(\n                target => fromImplForTargetEventLike<T>(ctx, target, eventName, options)\n            )\n        );\n\n    }\n\n    type ProxyMethod<T> = (\n        listener: (data: T) => void,\n        eventName: string,\n        options?: EventTargetLike.HasEventTargetAddRemove.Options\n    ) => void;\n\n    let proxy: {\n        on: ProxyMethod<T>;\n        off: ProxyMethod<T>;\n    };\n\n    if (EventTargetLikeAsValue.HasEventTargetAddRemove.match(target)) {\n        proxy = {\n            \"on\": (listener, eventName, options) => target.addEventListener(eventName, listener, options),\n            \"off\": (listener, eventName, options) => target.removeEventListener(eventName, listener, options)\n        };\n    } else if (EventTargetLikeAsValue.NodeStyleEventEmitter.match(target)) {\n        proxy = {\n            \"on\": (listener, eventName) => target.addListener(eventName, listener),\n            \"off\": (listener, eventName) => target.removeListener(eventName, listener)\n        };\n    } else if (EventTargetLikeAsValue.JQueryStyleEventEmitter.match(target)) {\n        proxy = {\n            \"on\": (listener, eventName) => target.on(eventName, listener),\n            \"off\": (listener, eventName) => target.off(eventName, listener)\n        };\n    } else if (EventTargetLikeAsValue.RxJSSubject.match(target)) {\n\n        let subscription: EventTargetLike.RxJSSubject.Subscription;\n\n        proxy = {\n            \"on\": listener => subscription = target.subscribe(data => listener(data)),\n            \"off\": () => subscription.unsubscribe()\n        };\n\n    } else {\n\n        id<never>(target);\n        assert(false);\n\n    }\n\n    const evt = new importProxy.Evt<T>();\n\n    const listener = (data: T) => evt.post(data);\n\n    ctx?.evtDoneOrAborted.attachOnce(\n        () => proxy.off(\n            listener,\n            eventName!,\n            options\n        )\n    );\n\n    proxy.on(listener, eventName!, options);\n\n    return evt;\n\n}\n\nfunction fromImplForObserver<Target, Entry>(\n    ctx: CtxLike<any> | undefined,\n    ObserverConstructor: ObserverConstructor<Target, Entry>,\n    target: Target\n): Evt<Entry> {\n\n    const evt = importProxy.Evt.create<Entry>();\n\n    const listener = ([entry]: Entry[]) => evt.post(entry);\n\n    const observer = new ObserverConstructor(listener);\n\n    observer.observe(target);\n\n    ctx?.evtDoneOrAborted.attachOnce(\n        () => observer.disconnect()\n    );\n\n    return evt;\n\n}\n\n/** https://docs.evt.land/api/evt/from */\nexport function from<K extends keyof dom.HTMLElementEventMap>(\n    ctx: CtxLike<any>,\n    target: EventTargetLike.HTMLElement,\n    eventName: K,\n    options?: EventTargetLike.HasEventTargetAddRemove.Options\n): Evt<dom.HTMLElementEventMap[K]>;\n\nexport function from<K extends keyof dom.WindowEventMap>(\n    ctx: CtxLike<any>,\n    target: EventTargetLike.Window,\n    eventName: K,\n    options?: EventTargetLike.HasEventTargetAddRemove.Options\n): Evt<dom.WindowEventMap[K]>;\n\nexport function from<K extends keyof dom.DocumentEventMap>(\n    ctx: CtxLike<any>,\n    target: EventTargetLike.Document,\n    eventName: K,\n    options?: EventTargetLike.HasEventTargetAddRemove.Options\n): Evt<dom.DocumentEventMap[K]>;\n\nexport function from<T>(\n    ctx: CtxLike<any>,\n    target: OneOrMany<\n        EventTargetLike.NodeStyleEventEmitter |\n        EventTargetLike.JQueryStyleEventEmitter\n    >,\n    eventName: string\n): Evt<T>;\nexport function from<T>(\n    ctx: CtxLike<any>,\n    target: OneOrMany<\n        EventTargetLike.HasEventTargetAddRemove<T>\n    >,\n    eventName: string,\n    options?: EventTargetLike.HasEventTargetAddRemove.Options\n): Evt<T>;\nexport function from<T>(\n    ctx: CtxLike<any>,\n    target: OneOrMany<EventTargetLike.RxJSSubject<T>>\n): Evt<T>;\n\nexport function from<T>(\n    ctx: CtxLike<any>,\n    target: PromiseLike<T>\n): Evt<T>;\n\nexport function from<Target, Entry>(\n    ctx: CtxLike<any>,\n    ObserverConstructor: ObserverConstructor<Target, Entry>,\n    target: Target\n): Evt<Entry>;\n\n\nexport function from<K extends keyof dom.HTMLElementEventMap>(\n    target: EventTargetLike.HTMLElement,\n    eventName: K,\n    options?: EventTargetLike.HasEventTargetAddRemove.Options\n): Evt<dom.HTMLElementEventMap[K]>;\nexport function from<K extends keyof dom.WindowEventMap>(\n    target: EventTargetLike.Window,\n    eventName: K,\n    options?: EventTargetLike.HasEventTargetAddRemove.Options\n): Evt<dom.WindowEventMap[K]>;\nexport function from<K extends keyof dom.DocumentEventMap>(\n    target: EventTargetLike.Document,\n    eventName: K,\n    options?: EventTargetLike.HasEventTargetAddRemove.Options\n): Evt<dom.DocumentEventMap[K]>;\nexport function from<T>(\n    target: OneOrMany<\n        EventTargetLike.NodeStyleEventEmitter |\n        EventTargetLike.JQueryStyleEventEmitter\n    >,\n    eventName: string\n): Evt<T>;\nexport function from<T>(\n    target: OneOrMany<\n        EventTargetLike.HasEventTargetAddRemove<T>\n    >,\n    eventName: string,\n    options?: EventTargetLike.HasEventTargetAddRemove.Options\n): Evt<T>;\nexport function from<T>(\n    target: OneOrMany<EventTargetLike.RxJSSubject<T>>\n): Evt<T>;\nexport function from<T>(\n    target: PromiseLike<T>\n): Evt<T>;\n\nexport function from<Target, Entry>(\n    ObserverConstructor: ObserverConstructor<Target, Entry>,\n    target: Target\n): Evt<Entry>;\n/*\n/^[A-Z]/.test(targetOrEventNameOrObserverConstructorOrObserverTarget.name\n    */\n\nexport function from<T, ObserverTarget = never>(\n    ctxOrTargetOrObserverConstructor: CtxLike<any> | OneOrMany<EventTargetLike<T>> | PromiseLike<T> | ObserverConstructor<ObserverTarget, T>,\n    targetOrEventNameOrObserverConstructorOrObserverTarget?: OneOrMany<EventTargetLike<T>> | string | PromiseLike<T> | ObserverConstructor<ObserverTarget, T> | ObserverTarget,\n    eventNameOrOptionsOrObserverTarget?: string | EventTargetLike.HasEventTargetAddRemove.Options | ObserverTarget,\n    options?: EventTargetLike.HasEventTargetAddRemove.Options\n): Evt<T> {\n\n    if (\"evtDoneOrAborted\" in ctxOrTargetOrObserverConstructor) {\n\n        assert(\n            typeGuard<OneOrMany<EventTargetLike<T>> | PromiseLike<T> | ObserverConstructor<ObserverTarget, T>>(targetOrEventNameOrObserverConstructorOrObserverTarget, true) &&\n            typeGuard<string | undefined | ObserverTarget>(eventNameOrOptionsOrObserverTarget, true) &&\n            typeGuard<EventTargetLike.HasEventTargetAddRemove.Options | undefined>(options, true)\n        );\n\n        if (typeof targetOrEventNameOrObserverConstructorOrObserverTarget === \"function\") {\n\n            assert(\n                typeGuard<ObserverTarget>(eventNameOrOptionsOrObserverTarget, true) &&\n                typeGuard<undefined>(options, true)\n            );\n\n            return fromImplForObserver(\n                ctxOrTargetOrObserverConstructor,\n                targetOrEventNameOrObserverConstructorOrObserverTarget,\n                eventNameOrOptionsOrObserverTarget\n            );\n\n        } else {\n\n            assert(\n                typeGuard<Exclude<typeof eventNameOrOptionsOrObserverTarget, ObserverTarget>>(eventNameOrOptionsOrObserverTarget, true)\n            );\n\n            return fromImplForTargetEventLike(\n                ctxOrTargetOrObserverConstructor,\n                targetOrEventNameOrObserverConstructorOrObserverTarget,\n                eventNameOrOptionsOrObserverTarget,\n                options\n            );\n\n        }\n\n\n    } else {\n\n        assert(\n            typeGuard<Exclude<typeof ctxOrTargetOrObserverConstructor, CtxLike<any>>>(ctxOrTargetOrObserverConstructor, true) &&\n            typeGuard<string | undefined | ObserverTarget>(targetOrEventNameOrObserverConstructorOrObserverTarget, true) &&\n            typeGuard<EventTargetLike.HasEventTargetAddRemove.Options | undefined>(eventNameOrOptionsOrObserverTarget, true)\n        );\n\n        if (typeof ctxOrTargetOrObserverConstructor === \"function\") {\n\n            assert(\n                typeGuard<ObserverTarget>(targetOrEventNameOrObserverConstructorOrObserverTarget, true) &&\n                typeGuard<undefined>(eventNameOrOptionsOrObserverTarget, true)\n            );\n\n            return fromImplForObserver(\n                undefined,\n                ctxOrTargetOrObserverConstructor,\n                targetOrEventNameOrObserverConstructorOrObserverTarget\n            );\n\n\n        } else {\n\n            assert(\n                typeGuard<Exclude<typeof targetOrEventNameOrObserverConstructorOrObserverTarget, ObserverTarget>>(\n                    targetOrEventNameOrObserverConstructorOrObserverTarget, true\n                )\n            );\n\n            return fromImplForTargetEventLike(\n                undefined,\n                ctxOrTargetOrObserverConstructor,\n                targetOrEventNameOrObserverConstructorOrObserverTarget,\n                eventNameOrOptionsOrObserverTarget\n            );\n\n        }\n\n\n\n    }\n\n}\n","import { Polyfill as WeakMap } from \"minimal-polyfills/WeakMap\";\nimport { importProxy } from \"./importProxy\";\nimport type { Ctx } from \"./types\";\n\n/** \n * https://docs.evt.land/api/evt/getctx\n * \n * Evt.getCtx(obj) an instance of Ctx<void>, always the same for a given object.\n * No strong reference to the object is created\n * when the object is no longer referenced it's associated Ctx will be freed from memory.\n */\nexport function getCtxFactory() {\n\n    const ctxByObj = new WeakMap<object, Ctx>();\n\n    function getCtx(obj: object): Ctx {\n\n        let ctx = ctxByObj.get(obj);\n\n        if (ctx === undefined) {\n\n            ctx = (new importProxy.Ctx());\n\n            ctxByObj.set(obj, ctx);\n\n        }\n\n        return ctx;\n\n    }\n\n    return getCtx;\n\n}\n","import \"minimal-polyfills/Array.prototype.find\";\nimport { importProxy } from \"./importProxy\";\nimport { create } from \"./Evt.create\";\nimport { getCtxFactory } from \"./Evt.getCtx\";\nimport { factorize } from \"./Evt.factorize\";\nimport { merge } from \"./Evt.merge\";\nimport { from } from \"./Evt.from\";\nimport { asPostable } from \"./Evt.asPostable\";\nimport { asyncPipe } from \"./Evt.asyncPipe\";\nimport { asNonPostable } from \"./Evt.asNonPostable\";\nimport { parsePropsFromArgs, matchAll } from \"./Evt.parsePropsFromArgs\";\nimport { newCtx } from \"./Evt.newCtx\";\nimport { LazyEvt } from \"./LazyEvt\";\nimport { Polyfill as Map, LightMap } from \"minimal-polyfills/Map\";\nimport { Polyfill as WeakMap } from \"minimal-polyfills/WeakMap\";\nimport * as runExclusive from \"run-exclusive\";\nimport { overwriteReadonlyProp } from \"tsafe/lab/overwriteReadonlyProp\";\nimport { typeGuard } from \"tsafe/typeGuard\";\nimport { Deferred } from \"../tools/Deferred\";\nimport { loosenType } from \"./Evt.loosenType\";\nimport { safeClearTimeout, safeSetTimeout, Timer } from \"../tools/safeSetTimeout\";\nimport { isPromiseLike } from \"tsafe/isPromiseLike\";\nimport { DetachedEvtError, TimeoutEvtError } from \"./types/EvtError\";\nimport * as nsCtxLike from \"./types/interfaces/CtxLike\";\nimport type { Handler, Operator, NonPostableEvt, StatefulEvt, NonPostableEvtLike, CtxLike } from \"./types\";\nimport { convertOperatorToStatelessFλ } from \"./util/convertOperatorToStatelessFLambda\";\nimport type { AsyncIterableEvt } from \"./types/AsyncIterableEvt\";\n\nconst runSideEffect = (sideEffect: () => void) => sideEffect();\n\n// NOTE: For compat with --no-check \n// https://github.com/asos-craigmorten/opine/issues/97#issuecomment-751806014\nconst { CtxLike: CtxLikeAsValue } = nsCtxLike;\n\n/** https://docs.evt.land/api/evt */\nexport type Evt<T> = import(\"./types/interfaces/Evt\").Evt<T>;\n\n\nclass EvtImpl<T> implements Evt<T> {\n\n    static readonly create = create;\n\n    static readonly newCtx = newCtx;\n\n    static readonly merge = merge;\n\n    static readonly from = from;\n\n    static readonly getCtx = getCtxFactory();\n\n    static readonly loosenType = loosenType;\n\n    static readonly factorize = factorize;\n\n    static readonly asPostable = asPostable;\n\n    static readonly asyncPipe = asyncPipe;\n\n    static readonly asNonPostable = asNonPostable;\n\n    private static __defaultMaxHandlers = 25;\n\n    static setDefaultMaxHandlers(n: number): void {\n        this.__defaultMaxHandlers = isFinite(n) ? n : 0;\n    }\n\n    toStateful(p1: any, p2?: CtxLike): StatefulEvt<any> {\n\n        const isP1Ctx = CtxLikeAsValue.match(p1);\n\n        const initialValue: any = isP1Ctx ? undefined : p1;\n        const ctx = p2 || (isP1Ctx ? p1 : undefined);\n\n        const out = new importProxy.StatefulEvt<any>(initialValue);\n\n        const callback = (data: T) => out.post(data);\n\n        if (!!ctx) {\n            this.attach(ctx, callback);\n        } else {\n            this.attach(callback);\n        }\n\n        return out;\n\n    }\n\n    get evtAttach(): Evt<Handler<T, any>> {\n        return this.lazyEvtAttach.evt;\n    }\n\n    get evtDetach(): Evt<Handler<T, any>> {\n        return this.lazyEvtDetach.evt;\n    }\n\n    private readonly lazyEvtAttach = new LazyEvt<Handler<T, any>>();\n    private readonly lazyEvtDetach = new LazyEvt<Handler<T, any>>();\n\n\n    private __maxHandlers: undefined | number = undefined;\n\n    setMaxHandlers(n: number): this {\n        this.__maxHandlers = isFinite(n) ? n : 0;\n        return this;\n    }\n\n    readonly postCount: number = 0;\n\n    private traceId: string | null = null;\n    private traceFormatter!: (data: T) => string;\n    private log!: Exclude<Parameters<NonPostableEvt<any>[\"enableTrace\"]>[0][\"log\"], false>;\n\n    enableTrace(\n        params: {\n            id: string,\n            formatter?: (data: T) => string,\n            log?: ((message?: any, ...optionalParams: any[]) => void) | false\n        }\n        //NOTE: Not typeof console.log as we don't want to expose types from node\n    ): void {\n\n        const { id, formatter, log } = params;\n\n        this.traceId = id;\n\n        this.traceFormatter = formatter || (\n            data => {\n                try {\n                    return JSON.stringify(data, null, 2);\n                } catch {\n                    return `${data}`;\n                }\n            }\n        );\n\n        this.log =\n            log === undefined ?\n                ((...inputs) => console.log(...inputs)) :\n                log === false ? undefined : log\n            ;\n\n    }\n\n    disableTrace(): this {\n        this.traceId = null;\n        return this;\n    }\n\n    private readonly handlers: Handler<T, any>[] = [];\n\n    private readonly handlerTriggers: LightMap<\n        Handler<T, any>,\n        (opResult: readonly [any]) => PromiseLike<void> | undefined\n    > = new Map();\n\n\n    //NOTE: An async handler ( attached with waitFor ) is only eligible to handle a post if the post\n    //occurred after the handler was set. We don't want to waitFor event from the past.\n    //private readonly asyncHandlerChronologyMark = new WeakMap<ImplicitParams.Async, number>();\n    private get asyncHandlerChronologyMark(): WeakMap<\n        Handler.PropsFromMethodName.Async,\n        number\n    > {\n        return ((this as any)[\"~internal\"] ??= {})[\"asyncHandlerChronologyMark\"] ??= new WeakMap<any, any>();\n    }\n\n    //NOTE: There is an exception to the above rule, we want to allow async waitFor loop \n    //do so we have to handle the case where multiple event would be posted synchronously.\n    private get asyncHandlerChronologyExceptionRange(): WeakMap<\n        Handler.PropsFromMethodName.Async,\n        { lowerMark: number; upperMark: number; }\n    > {\n        return ((this as any)[\"~internal\"] ??= {})[\"asyncHandlerChronologyExceptionRange\"] ??= new WeakMap<any, any>();\n    }\n\n\n    private get invocableOpByOp(): WeakMap<\n        Operator<T, any>,\n        Operator.fλ.Stateless<T, any>\n    > {\n        return ((this as any)[\"~internal\"] ??= {})[\"invocableOpByOp\"] ??= new WeakMap<any, any>();\n    }\n\n    getInvocableOp<U>(op: Operator<T, U>): Operator.fλ.Stateless<T, U> {\n\n        const invocableOp = this.invocableOpByOp.get(op);\n\n        if (invocableOp === undefined) {\n            throw new Error([\n                \"Provided operator isn't the operator of any handler\",\n                \"currently attached to the Evt instance\"\n            ].join(\" \"));\n        }\n\n        return invocableOp;\n\n    }\n\n    /*\n    NOTE: Used as Date.now() would be used to compare if an event is anterior \n    or posterior to an other. We don't use Date.now() because two call within\n    less than a ms will return the same value unlike this function.\n    */\n    private __currentChronologyMark = 0;\n    private getChronologyMark() {\n        return this.__currentChronologyMark++;\n    }\n\n\n    private asyncHandlerCount: number = 0;\n\n    private detachHandler(\n        handler: Handler<T, any>,\n        wTimer: [Timer | undefined],\n        rejectPr: (error: DetachedEvtError) => void\n    ) {\n\n        const index = this.handlers.indexOf(handler);\n\n        if (index < 0) {\n            return false;\n        }\n\n        if (typeGuard<Handler<T, any, CtxLike<any>>>(handler, !!handler.ctx)) {\n            handler.ctx.zz__removeHandler(handler);\n        }\n\n\n        this.handlers.splice(index, 1);\n\n        if (handler.async) {\n            this.asyncHandlerCount--;\n        }\n\n        this.handlerTriggers.delete(handler);\n\n        if (wTimer[0] !== undefined) {\n\n            safeClearTimeout(wTimer[0]);\n\n            rejectPr(new DetachedEvtError());\n\n        }\n\n        this.lazyEvtDetach.post(handler);\n\n        return true;\n\n    }\n\n\n    private triggerHandler<U>(\n        handler: Handler<T, U>,\n        wTimer: [Timer | undefined],\n        resolvePr: ((transformedData: any) => void) | undefined,\n        opResult: readonly [U] //TODO: Or readonly [ any ] ?? \n    ): PromiseLike<void> | undefined {\n\n        const { callback, once } = handler;\n\n        if (wTimer[0] !== undefined) {\n            safeClearTimeout(wTimer[0]);\n            wTimer[0] = undefined;\n        }\n\n        if (once) {\n            handler.detach();\n        }\n\n        const [transformedData] = opResult;\n\n        const prOrValue = callback?.call(\n            this,\n            transformedData\n        );\n\n        resolvePr?.(transformedData);\n\n        return isPromiseLike(prOrValue) ? prOrValue : undefined;\n\n    }\n\n    private addHandler<U>(\n        propsFromArgs: Handler.PropsFromArgs<T, U>,\n        propsFromMethodName: Handler.PropsFromMethodName\n    ): Handler<T, U> {\n\n        this.invocableOpByOp.set(\n            propsFromArgs.op,\n            convertOperatorToStatelessFλ(propsFromArgs.op)\n        );\n\n        const d = new Deferred<U>();\n\n        const wTimer: [Timer | undefined] = [undefined];\n\n        const handler: Handler<T, U> = {\n            ...propsFromArgs,\n            ...propsFromMethodName,\n            \"detach\": () => this.detachHandler(handler, wTimer, d.reject),\n            \"promise\": d.pr\n        };\n\n        if (typeof handler.timeout === \"number\") {\n\n            wTimer[0] = safeSetTimeout(() => {\n\n                wTimer[0] = undefined;\n\n                handler.detach();\n\n                d.reject(new TimeoutEvtError(handler.timeout!));\n\n            }, handler.timeout);\n\n        }\n\n        const handlerTrigger: (opResult: readonly [U]) => PromiseLike<void> | undefined\n            = opResult => this.triggerHandler(\n                handler,\n                wTimer,\n                d.isPending ? d.resolve : undefined,\n                opResult\n            );\n\n        this.handlerTriggers.set(\n            handler,\n            handlerTrigger\n        );\n\n        if (handler.async) {\n\n            this.asyncHandlerChronologyMark.set(\n                handler,\n                this.getChronologyMark()\n            );\n\n        }\n\n        if (handler.prepend) {\n\n            let i: number;\n\n            for (i = 0; i < this.handlers.length; i++) {\n\n                if (this.handlers[i].extract) {\n                    continue;\n                }\n\n                break;\n\n            }\n\n            this.handlers.splice(i, 0, handler);\n\n        } else {\n\n            this.handlers.push(handler);\n\n        }\n\n        if (handler.async) {\n            this.asyncHandlerCount++;\n        }\n\n        this.checkForPotentialMemoryLeak();\n\n        if (typeGuard<Handler<T, U, CtxLike<any>>>(handler, !!handler.ctx)) {\n            handler.ctx.zz__addHandler(handler, this);\n        }\n\n        onAddHandlerByEvt.get(this)?.(handler, handlerTrigger);\n\n        //NOTE: Can happen for example if this is a StatefulEvt \n        //and the handler is \"once\" and the matcher match the state \n        //We don't want to post an attach if the handler is already detached.\n        if (this.handlerTriggers.has(handler)) {\n\n            this.lazyEvtAttach.post(handler);\n\n        }\n\n        return handler;\n\n    }\n\n\n\n    private checkForPotentialMemoryLeak(): void {\n\n        const maxHandlers = this.__maxHandlers !== undefined ?\n            this.__maxHandlers :\n            EvtImpl.__defaultMaxHandlers\n            ;\n\n\n        if (\n            maxHandlers === 0 ||\n            this.handlers.length % (maxHandlers + 1) !== 0) {\n            return;\n        }\n\n        let message = [\n            `MaxHandlersExceededWarning: Possible Evt memory leak detected.`,\n            `${this.handlers.length} handlers attached${this.traceId ? ` to \"${this.traceId}\"` : \"\"}.\\n`,\n            `Use Evt.prototype.setMaxHandlers(n) to increase limit on a specific Evt.\\n`,\n            `Use Evt.setDefaultMaxHandlers(n) to change the default limit currently set to ${EvtImpl.__defaultMaxHandlers}.\\n`,\n        ].join(\"\");\n\n        const map = new Map<string, number>();\n\n        this.getHandlers()\n            .map(({ ctx, async, once, prepend, extract, op, callback }) => ({\n                \"hasCtx\": !!ctx,\n                once,\n                prepend,\n                extract,\n                \"isWaitFor\": async,\n                ...(op === matchAll ? {} : { \"op\": op.toString() }),\n                ...(!callback ? {} : { \"callback\": callback.toString() })\n            }))\n            .map(obj =>\n                \"{\\n\" + Object.keys(obj)\n                    .map(key => `  ${key}: ${(obj as any)[key]}`)\n                    .join(\",\\n\") + \"\\n}\"\n            )\n            .forEach(str => map.set(str, (map.has(str) ? map.get(str)! : 0) + 1))\n            ;\n\n        message += \"\\n\" + Array.from(map.keys())\n            .map(str => `${map.get(str)} handler${map.get(str) === 1 ? \"\" : \"s\"} like:\\n${str}`)\n            .join(\"\\n\") + \"\\n\";\n\n        if (this.traceId === null) {\n\n            message += \"\\n\" + [\n                `To validate the identify of the Evt instance that is triggering this warning you can call`,\n                `Evt.prototype.enableTrace({ \"id\": \"My evt id\", \"log\": false }) on the Evt that you suspect.\\n`\n            ].join(\" \");\n\n        }\n\n        try {\n            console.warn(message);\n        } catch {\n        }\n\n    }\n\n    isHandledByOp<U>(op: Operator<T, U>, data: T): boolean {\n\n        let hasSideEffect = false;\n\n        let invocableOp: Operator.fλ.Stateless<T, U>;\n\n        try {\n\n            invocableOp = this.getInvocableOp(op);\n\n        } catch {\n\n            return false;\n\n        }\n\n        const opResult = invocableOp(\n            data,\n            () => hasSideEffect = true\n        );\n\n        return opResult !== null || hasSideEffect;\n\n    }\n\n\n    private trace(data: T) {\n\n        if (this.traceId === null) {\n            return;\n        }\n\n        let message = `(${this.traceId}) `;\n\n        const isExtracted = !!this.handlers.find(\n            ({ extract, op }) => (\n                extract &&\n                this.isHandledByOp(op, data)\n            )\n        );\n\n        if (isExtracted) {\n\n            message += \"extracted \";\n\n        } else {\n\n            const handlerCount = this.handlers\n                .filter(\n                    ({ extract, op }) => !extract &&\n                        this.isHandledByOp(op, data)\n                )\n                .length;\n\n            message += `${handlerCount} handler${(handlerCount > 1) ? \"s\" : \"\"}, `;\n\n        }\n\n        this.log?.(message + this.traceFormatter(data));\n\n    }\n\n    /** Return [ isExtracted, prAllHandlerCallbacksResolved ] */\n    private postSync(data: T): readonly [boolean, Promise<void>] {\n\n        const prAllHandlerCallbacksResolved: PromiseLike<void>[] = [];\n\n        const getReturnValue = (isExtracted: boolean) => [\n            isExtracted,\n            Promise.all(prAllHandlerCallbacksResolved).then(() => { })\n        ] as const;\n\n\n        for (const handler of [...this.handlers]) {\n\n            const { async, op, extract } = handler;\n\n            if (async) {\n                continue;\n            }\n\n            //NOTE: If detached while executing the operator\n            //we still want to trigger the handler.\n            const handlerTrigger = this.handlerTriggers.get(handler);\n\n            const opResult = this.getInvocableOp(op)(\n                data,\n                runSideEffect\n            );\n\n            if (opResult === null) {\n                continue;\n            }\n\n            //NOTE: Possible if detached while in the loop.\n            if (!handlerTrigger) {\n                continue;\n            }\n\n            const prOrUndefined = handlerTrigger(opResult);\n\n            if (prOrUndefined !== undefined) {\n                prAllHandlerCallbacksResolved.push(prOrUndefined);\n            }\n\n            if (extract) {\n                return getReturnValue(true);\n            }\n\n        }\n\n        return getReturnValue(false);\n\n    }\n\n    private postAsyncFactory() {\n        return runExclusive.buildMethodCb(\n            (data: T, postChronologyMark: number, releaseLock?) => {\n\n                if (this.asyncHandlerCount === 0) {\n                    releaseLock();\n                    return;\n                }\n\n                const promises: Promise<void>[] = [];\n\n                let chronologyMarkStartResolveTick: number;\n\n                //NOTE: Must be before handlerTrigger call.\n                Promise.resolve().then(\n                    () => chronologyMarkStartResolveTick = this.getChronologyMark()\n                );\n\n\n                for (const handler of [...this.handlers]) {\n\n                    if (!handler.async) {\n                        continue;\n                    }\n\n                    const opResult = this.getInvocableOp(handler.op)(\n                        data,\n                        runSideEffect\n                    );\n\n                    if (opResult === null) {\n                        continue;\n                    }\n\n                    const handlerTrigger = this.handlerTriggers.get(handler);\n\n                    if (!handlerTrigger) {\n                        continue;\n                    }\n\n                    const shouldCallHandlerTrigger = (() => {\n\n                        const handlerMark = this.asyncHandlerChronologyMark.get(handler)!;\n\n                        if (postChronologyMark > handlerMark) {\n                            return true;\n                        }\n\n                        const exceptionRange = this.asyncHandlerChronologyExceptionRange.get(handler);\n\n                        return (\n                            exceptionRange !== undefined &&\n                            exceptionRange.lowerMark < postChronologyMark &&\n                            postChronologyMark < exceptionRange.upperMark &&\n                            handlerMark > exceptionRange.upperMark\n                        );\n\n                    })();\n\n                    if (!shouldCallHandlerTrigger) {\n                        continue;\n                    }\n\n                    promises.push(\n                        new Promise<void>(\n                            resolve => handler.promise\n                                .then(() => resolve())\n                                .catch(() => resolve())\n                        )\n                    );\n\n                    handlerTrigger(opResult);\n\n\n                }\n\n                if (promises.length === 0) {\n                    releaseLock();\n                    return;\n                }\n\n                const handlersDump = [...this.handlers];\n\n                Promise.all(promises).then(() => {\n\n                    for (const handler of this.handlers) {\n\n                        if (!handler.async) {\n                            continue;\n                        }\n\n                        if (handlersDump.indexOf(handler) >= 0) {\n                            continue;\n                        }\n\n                        this.asyncHandlerChronologyExceptionRange.set(\n                            handler,\n                            {\n                                \"lowerMark\": postChronologyMark,\n                                \"upperMark\": chronologyMarkStartResolveTick\n                            }\n                        );\n\n                    }\n\n                    releaseLock();\n\n                });\n\n            }\n        );\n    }\n\n    declare private postAsync: (\n        (\n            data: T,\n            postChronologyMark: number\n        ) => void\n    ) | undefined;\n\n    private static readonly propsFormMethodNames: Record<\n        \"waitFor\" | \"attach\" | \"attachExtract\" | \"attachPrepend\" | \"attachOnce\" |\n        \"attachOncePrepend\" | \"attachOnceExtract\"\n        ,\n        Handler.PropsFromMethodName\n    > = {\n            \"waitFor\": { \"async\": true, \"extract\": false, \"once\": true, \"prepend\": false },\n            \"attach\": { \"async\": false, \"extract\": false, \"once\": false, \"prepend\": false },\n            \"attachExtract\": { \"async\": false, \"extract\": true, \"once\": false, \"prepend\": true },\n            \"attachPrepend\": { \"async\": false, \"extract\": false, \"once\": false, \"prepend\": true },\n            \"attachOnce\": { \"async\": false, \"extract\": false, \"once\": true, \"prepend\": false },\n            \"attachOncePrepend\": { \"async\": false, \"extract\": false, \"once\": true, \"prepend\": true },\n            \"attachOnceExtract\": { \"async\": false, \"extract\": true, \"once\": true, \"prepend\": true }\n        };\n\n    isHandled(data: T): boolean {\n        return !!this.getHandlers()\n            .find(({ op }) => this.isHandledByOp(op, data))\n            ;\n    }\n\n    getHandlers(): Handler<T, any>[] {\n        return [...this.handlers];\n    }\n\n    detach(ctx?: CtxLike<any>): Handler<T, any, any>[] {\n\n        const detachedHandlers: Handler<T, any>[] = [];\n\n        for (const handler of this.getHandlers()) {\n\n            if (ctx !== undefined && handler.ctx !== ctx) {\n                continue;\n            }\n\n            const wasStillAttached = handler.detach();\n\n            //NOTE: It should not be possible.\n            if (!wasStillAttached) {\n                continue;\n            }\n\n            detachedHandlers.push(handler);\n\n        }\n\n        return detachedHandlers;\n\n    }\n\n    pipe(...args: any[]): Evt<any> {\n\n        const evtDelegate = new EvtImpl<any>();\n\n        this.addHandler(\n            {\n                ...parsePropsFromArgs<T>(args, \"pipe\"),\n                \"callback\": (transformedData: any) => evtDelegate.post(transformedData)\n            },\n            EvtImpl.propsFormMethodNames.attach\n        );\n\n        return evtDelegate;\n\n    }\n\n    waitFor(...args: any[]): Promise<any> {\n        return this.addHandler(\n            parsePropsFromArgs<T>(args, \"waitFor\"),\n            EvtImpl.propsFormMethodNames.waitFor\n        ).promise;\n    }\n\n    [Symbol.asyncIterator]() {\n        return this.iter()[Symbol.asyncIterator]();\n    }\n\n    iter(...args: any[]): AsyncIterableEvt<any, any> {\n\n        const props = parsePropsFromArgs<T>(args, \"waitFor\");\n\n        const ctx = (props.ctx ?? newCtx()) as ReturnType<typeof newCtx>;\n\n        const self = this;\n\n        return {\n            ctx,\n            [Symbol.asyncIterator]() {\n\n                const previousDonePostCount = ctx.evtDoneOrAborted.postCount;\n\n                const timerWrap = (() => {\n\n                    const { timeout } = props;\n\n                    if (timeout === undefined) {\n                        return undefined;\n                    }\n\n                    const setTimeoutCallback = () => {\n                        const error = new TimeoutEvtError(timeout);\n                        ctx.abort(error);\n                    };\n\n                    const timer = setTimeout(setTimeoutCallback, timeout);\n\n                    return { timeout, setTimeoutCallback, timer };\n\n                })();\n\n                const evtProxy = self\n                    .pipe(ctx, props.op)\n                    .pipe((data, registerSideEffect) => {\n\n                        if (timerWrap !== undefined) {\n\n                            registerSideEffect(() => {\n\n                                clearTimeout(timerWrap.timer);\n\n                                timerWrap.timer = setTimeout(timerWrap.setTimeoutCallback, timerWrap.timeout);\n                            });\n\n                        }\n\n                        return [data];\n                    });\n\n                const events: [T][] = [];\n\n                evtProxy.attach(event => events.push([event]));\n\n                if (timerWrap !== undefined) {\n\n                    const { timer } = timerWrap;\n\n                    ctx.evtDoneOrAborted.attachOnce(\n                        event => event.type === \"DONE\",\n                        () => clearTimeout(timer)\n                    );\n\n                }\n\n                return {\n                    async next() {\n\n                        let eventWrap = events.shift();\n\n                        if (eventWrap === undefined) {\n\n                            const dEventWrap = new Deferred<[T] | undefined>();\n\n                            if (previousDonePostCount < ctx.evtDoneOrAborted.postCount) {\n                                return { \"done\": true };\n                            }\n\n                            const ctx2 = newCtx();\n\n                            ctx.evtDoneOrAborted.attachOnce(\n                                ctx2,\n                                () => dEventWrap.resolve(undefined)\n                            );\n\n                            evtProxy.attachOnceExtract(ctx2, event => {\n                                ctx2.done();\n                                dEventWrap.resolve([event])\n                            });\n\n                            eventWrap = await dEventWrap.pr;\n\n                            if (eventWrap === undefined) {\n                                return { \"done\": true };\n                            }\n\n                        }\n\n                        const out = { \"done\": false, \"value\": eventWrap[0] } as any;\n\n                        return out;\n\n                    },\n                    return() {\n\n                        self.detach(ctx);\n\n                        return { \"done\": true } as any;\n                    },\n                };\n            }\n\n        };\n\n\n    }\n\n\n\n\n    $attach(...args: any[]) {\n        return this.attach(...args);\n    }\n\n    attach(...args: any[]) {\n        return this.__attachX(args, \"attach\");\n    }\n\n    $attachOnce(...args: any[]) {\n        return this.attachOnce(...args);\n    }\n\n    attachOnce(...args: any[]) {\n        return this.__attachX(args, \"attachOnce\");\n    }\n\n    $attachExtract(...args: any[]) {\n        return this.attachExtract(...args);\n    }\n\n    attachExtract(...args: any[]) {\n        return this.__attachX(args, \"attachExtract\");\n    }\n\n    $attachPrepend(...args: any[]) {\n        return (this.attachPrepend as any)(...args);\n    }\n\n    attachPrepend(...args: any[]) {\n        return this.__attachX(args, \"attachPrepend\");\n    }\n\n    $attachOncePrepend(...args: any[]) {\n        return this.attachOncePrepend(...args);\n    }\n\n    attachOncePrepend(...args: any[]) {\n        return this.__attachX(args, \"attachOncePrepend\");\n    }\n\n    $attachOnceExtract(...args: any[]) {\n        return this.attachOnceExtract(...args);\n    }\n\n    attachOnceExtract(...args: any[]) {\n        return this.__attachX(args, \"attachOnceExtract\");\n    }\n\n    private __attachX(\n        args: any[],\n        methodName: keyof typeof EvtImpl.propsFormMethodNames\n    ): any {\n\n        const propsFromArgs = parsePropsFromArgs<T>(args, \"attach*\");\n\n        const handler = this.addHandler(\n            propsFromArgs,\n            EvtImpl.propsFormMethodNames[methodName]\n        );\n\n        return propsFromArgs.timeout === undefined ?\n            this :\n            handler.promise\n            ;\n\n    }\n\n    postAsyncOnceHandled(data: T): number | Promise<number> {\n\n        if (this.isHandled(data)) {\n            return this.post(data);\n        }\n\n        const d = new Deferred<number>();\n\n        this.evtAttach.attachOnce(\n            ({ op }) => this.isHandledByOp(op, data),\n            () => Promise.resolve().then(() => d.resolve(this.post(data)))\n        );\n\n        return d.pr;\n\n    }\n\n    private postOrPostAndWait(data: T, wait: false): number;\n    private postOrPostAndWait(data: T, wait: true): Promise<void>;\n    private postOrPostAndWait(data: T, wait: boolean): number | Promise<void> {\n\n        this.trace(data);\n\n        overwriteReadonlyProp(this, \"postCount\", this.postCount + 1);\n\n        //NOTE: Must be before postSync.\n        const postChronologyMark = this.getChronologyMark();\n\n        const [isExtracted, prAllHandlerCallbacksResolved] = this.postSync(data);\n\n        const getReturnValue = wait ?\n            () => prAllHandlerCallbacksResolved :\n            () => this.postCount;\n\n        if (isExtracted) {\n            return getReturnValue();\n        }\n\n        if (this.postAsync === undefined) {\n\n            if (this.asyncHandlerCount === 0) {\n                return getReturnValue();\n            }\n\n            this.postAsync = this.postAsyncFactory();\n\n        }\n\n        this.postAsync(data, postChronologyMark);\n\n        return getReturnValue();\n\n    }\n\n    post(data: T) {\n        return this.postOrPostAndWait(data, false);\n    }\n\n    postAndWait(data: T) {\n        return this.postOrPostAndWait(data, true);\n    }\n\n}\n\n/** \n * Can be seen as a protected method that can be \n * optionally be implemented by class extending Evt.\n * \n * Should only be accessible from within the module.\n * Basically it is for allowing StatefulEvt to execute\n * the callback on attach.\n */\nexport const onAddHandlerByEvt = new WeakMap<\n    NonPostableEvtLike<any>,\n    (\n        handler: Handler<any, any>,\n        handlerTrigger: (opResult: readonly [any]) => PromiseLike<void> | undefined\n    ) => void>();\n\n\nexport const Evt: {\n    new <T>(): Evt<T>;\n    readonly prototype: Evt<any>;\n\n    readonly create: typeof create;\n\n    readonly newCtx: typeof newCtx;\n\n    readonly merge: typeof merge;\n\n    readonly from: typeof from;\n\n    readonly getCtx: ReturnType<typeof getCtxFactory>;\n\n    readonly loosenType: typeof loosenType;\n\n    readonly factorize: typeof factorize;\n\n    readonly asPostable: typeof asPostable;\n\n    readonly asyncPipe: typeof asyncPipe;\n\n    readonly asNonPostable: typeof asNonPostable;\n\n    /** https://docs.evt.land/api/evt/setdefaultmaxhandlers */\n    setDefaultMaxHandlers(n: number): void;\n\n} = EvtImpl;\n\ntry { overwriteReadonlyProp(Evt as any, \"name\", \"Evt\"); } catch { }\n\nimportProxy.Evt = Evt;\n\n","import type { SwapEvtType, UnpackEvt, NonPostableEvtLike} from \"./types\";\n\n/**\n * https://docs.evt.land/api/evt/loosenType\n */\nexport function loosenType<E extends NonPostableEvtLike<any>, SupersetOfT>(\n    evt: E\n): UnpackEvt<E> extends SupersetOfT ?\n    SwapEvtType<typeof evt, SupersetOfT> : \"NOT A SUPERSET\" {\n    return evt as any;\n}\n\n/*\nimport { Evt } from \"./Evt\";\nconst x: Evt<boolean> = loosenType(new Evt<true>()); x;\nconst y: Evt<boolean> = loosenType(new Evt<number>()); y;\n*/\n\n\n\n","\nimport { importProxy } from \"./importProxy\";\nimport type { UnpackEvt, Evt, CtxLike, NonPostableEvtLike } from \"./types\";\n\nexport function mergeImpl<EvtUnion extends NonPostableEvtLike<any>>(\n    ctx: CtxLike<any> | undefined,\n    evts: readonly EvtUnion[]\n): Evt<UnpackEvt<EvtUnion>> {\n\n    const evtUnion = new importProxy.Evt<UnpackEvt<EvtUnion>>();\n\n    const callback = (data: UnpackEvt<typeof evtUnion>) => evtUnion.post(data)\n\n    evts.forEach(\n        evt => {\n\n            if (ctx === undefined) {\n                evt.attach(callback);\n            } else {\n                evt.attach(ctx, callback);\n            }\n\n        }\n    );\n\n    return evtUnion;\n\n}\n\n\n\n/** https://docs.evt.land/api/evt/merge */\nexport function merge<EvtUnion extends NonPostableEvtLike<any>>(\n    ctx: CtxLike<any>,\n    evts: readonly EvtUnion[]\n): Evt<UnpackEvt<EvtUnion>>;\nexport function merge<EvtUnion extends NonPostableEvtLike<any>>(\n    evts: readonly EvtUnion[]\n): Evt<UnpackEvt<EvtUnion>>;\nexport function merge<EvtUnion extends NonPostableEvtLike<any>>(\n    p1: CtxLike<any> | readonly EvtUnion[],\n    p2?: readonly EvtUnion[]\n): Evt<UnpackEvt<EvtUnion>> {\n\n    return \"length\" in p1 ?\n        mergeImpl(undefined, p1) :\n        mergeImpl(p1, p2!)\n        ;\n\n\n}","import { importProxy } from \"./importProxy\";\nimport type { Ctx } from \"./Ctx\";\n\n/** \n * https://docs.evt.land/api/evt/newctx\n * \n * return a new Ctx instance\n * */\nexport function newCtx<T = void>(): Ctx<T>{\n    return new importProxy.Ctx();\n}","\nimport type { Operator } from \"./types/Operator\"\nimport { id } from \"tsafe/id\";\nimport { compose } from \"./util/compose\";\nimport { typeGuard } from \"tsafe/typeGuard\"\nimport type { CtxLike, Handler } from \"./types\";\n\nexport function matchAll() { return true; }\n\nconst canBeOperator = (p: undefined | CtxLike<any> | Operator<any, any>): boolean => {\n    return (\n        p !== undefined &&\n        typeGuard<Operator<any, any>>(p, true) &&\n        (\n            typeof p === \"function\" ||\n            typeof p[0] === \"function\"\n        )\n    );\n};\n\nconst defaultParams: Handler.PropsFromArgs<any, any> = {\n    \"op\": matchAll,\n    \"ctx\": undefined,\n    \"timeout\": undefined,\n    \"callback\": undefined\n};\n\nexport function parsePropsFromArgs<T>(\n    inputs: readonly any[],\n    methodName: \"waitFor\" | \"attach*\" | \"pipe\"\n): Handler.PropsFromArgs<T, any> {\n\n    type Out = Handler.PropsFromArgs<T, any>;\n\n    switch (methodName) {\n        case \"pipe\": {\n\n            //[]\n            //[undefined] ( not valid but user would expect it to work )\n            //[ ctx, ...op[] ]\n            //[ ...op[] ]\n\n            const getOpWrap = (ops: [Operator<T, any>, ...Operator<any, any>[]]) =>\n                ops.length === 0 ?\n                    {}\n                    :\n                    { \"op\": ops.length === 1 ? ops[0] : compose(...ops) }\n                ;\n\n            if (canBeOperator(inputs[0])) {\n\n                //[ ...op[] ]\n\n                return id<Out>({\n                    ...defaultParams,\n                    ...getOpWrap(inputs as any)\n                });\n\n            } else {\n\n                //[]\n                //[ ctx, ...Operator.fλ[] ]\n\n                const [ctx, ...rest] = inputs;\n\n                return id<Out>({\n                    ...defaultParams,\n                    ...(ctx !== undefined ? { ctx } : {}),\n                    ...getOpWrap(rest as any)\n                });\n\n            }\n\n\n        } break;\n\n        case \"waitFor\": {\n\n            //[ op, ctx, timeout ]\n            //[ op, ctx, undefined ]\n            //[ op, ctx ]\n            //[ op, timeout ]\n            //[ op, undefined ]\n            //[ ctx, timeout ]\n            //[ ctx, undefined ]\n            //[ op ]\n            //[ ctx ]\n            //[ timeout ]\n            //[ undefined ]\n            //[ callback ]\n\n            return parsePropsFromArgs(\n                [\n                    //If the last element is undefined, remove it.\n                    ...inputs.filter(\n                        (value, index) => !(\n                            index === inputs.length - 1 &&\n                            value === undefined\n                        )\n                    ),\n                    defaultParams.callback\n                ],\n                \"attach*\"\n            );\n\n        } break;\n        case \"attach*\": {\n\n            //NOTE: when callback is undefined call has been forward from waitFor.\n\n            //[ op, ctx, timeout, callback ]\n            //[ op, ctx, timeout, undefined ]\n            //[ op, ctx, callback ]\n            //[ op, ctx, undefined ]\n            //[ op, timeout, callback ]\n            //[ op, timeout, undefined ]\n            //[ ctx, timeout, callback ]\n            //[ ctx, timeout, undefined ]\n            //[ op, callback ]\n            //[ op, undefined ]\n            //[ ctx, callback ]\n            //[ ctx, undefined ]\n            //[ timeout, callback ]\n            //[ timeout, undefined ]\n            //[ callback ]\n            //[ undefined ]\n\n            const n = inputs.length as 4 | 3 | 2 | 1 | 0;\n\n            switch (n) {\n                case 4: {\n\n                    //[ op, ctx, timeout, callback ]\n                    const [p1, p2, p3, p4] = inputs;\n\n                    return id<Out>({\n                        ...defaultParams,\n                        \"op\": p1,\n                        \"ctx\": p2,\n                        \"timeout\": p3,\n                        \"callback\": p4\n                    });\n\n                }\n                case 3: {\n\n                    //[ op, ctx, callback ]\n                    //[ op, timeout, callback ]\n                    //[ ctx, timeout, callback ]\n                    const [p1, p2, p3] = inputs;\n                    if (typeof p2 === \"number\") {\n                        //[ op, timeout, callback ]\n                        //[ ctx, timeout, callback ]\n\n                        const timeout: Out[\"timeout\"] = p2;\n                        const callback: Out[\"callback\"] = p3;\n\n                        if (canBeOperator(p1)) {\n                            //[ op, timeout, callback ]\n                            return id<Out>({\n                                ...defaultParams,\n                                timeout,\n                                callback,\n                                \"op\": p1\n                            });\n\n                        } else {\n                            //[ ctx, timeout, callback ]\n\n                            return id<Out>({\n                                ...defaultParams,\n                                timeout,\n                                callback,\n                                \"ctx\": p1\n                            });\n\n                        }\n                    } else {\n                        //[ op, ctx, callback ]\n                        return id<Out>({\n                            ...defaultParams,\n                            \"op\": p1,\n                            \"ctx\": p2,\n                            \"callback\": p3\n                        });\n\n                    }\n\n                }\n                case 2: {\n\n                    //[ op, callback ]\n                    //[ ctx, callback ]\n                    //[ timeout, callback ]\n                    const [p1, p2] = inputs;\n                    if (typeof p1 === \"number\") {\n                        //[ timeout, callback ]\n                        return id<Out>({\n                            ...defaultParams,\n                            \"timeout\": p1,\n                            \"callback\": p2\n                        });\n                    } else {\n                        //[ op, callback ]\n                        //[ ctx, callback ]\n                        const callback: Out[\"callback\"] = p2;\n                        if (canBeOperator(p1)) {\n\n                            return id<Out>({\n                                ...defaultParams,\n                                callback,\n                                \"op\": p1\n                            });\n\n                        } else {\n\n                            return id<Out>({\n                                ...defaultParams,\n                                callback,\n                                \"ctx\": p1\n                            });\n\n                        }\n                    }\n\n                }\n                case 1: {\n\n                    //[ callback ]\n                    const [p] = inputs;\n\n                    return id<Out>({\n                        ...defaultParams,\n                        \"callback\": p\n                    });\n\n                }\n                case 0: {\n                    return id<Out>({ ...defaultParams });\n                }\n\n            }\n\n\n        } break;\n\n    }\n\n}\n\n","import { overwriteReadonlyProp } from \"tsafe/lab/overwriteReadonlyProp\";\nimport { importProxy } from \"./importProxy\";\nimport type { Evt } from \"./types\";\n\nexport class LazyEvt<T> {\n\n    private initialPostCount = 0;\n\n    get evt(): Evt<T> {\n\n        if (this.__evt === undefined) {\n            this.__evt = new importProxy.Evt();\n            overwriteReadonlyProp(this.__evt, \"postCount\", this.initialPostCount);\n        }\n\n        return this.__evt;\n\n    }\n\n    declare private __evt: Evt<T>;\n\n    private __post(data: T, doWait: false): number;\n    private __post(data: T, doWait: true): Promise<void>;\n    private __post(data: T, doWait: boolean): number | Promise<void> {\n\n        if (this.__evt === undefined) {\n\n            return ++this.initialPostCount;\n\n        }\n\n        return this.__evt[doWait ? \"postAndWait\" : \"post\"](data);\n\n    }\n\n    post(data: T) {\n        return this.__post(data, false);\n    }\n\n    postAndWait(data: T) {\n        return this.__post(data, true);\n    }\n\n}\n","\nimport type { Ctx } from \"./Ctx\";\nimport type { Evt } from \"./Evt\";\nimport type { StatefulEvt } from \"./StatefulEvt\";\n\n/** Manually handling circular import so React Native does not gives warning. */\nexport const importProxy: {\n    Ctx: typeof Ctx;\n    Evt: typeof Evt;\n    StatefulEvt: typeof StatefulEvt;\n} = {} as any;\n\n\n\n","\nimport { typeGuard } from \"tsafe/typeGuard\";\n\nexport type EventTargetLike<T> =\n    EventTargetLike.HasEventTargetAddRemove<T> |\n    EventTargetLike.NodeStyleEventEmitter |\n    EventTargetLike.JQueryStyleEventEmitter |\n    EventTargetLike.RxJSSubject<T>\n    ;\n\nexport namespace EventTargetLike {\n\n    export type HTMLElement = HasEventTargetAddRemove<any> & {\n        innerText: string;\n    };\n\n    export type Window = HasEventTargetAddRemove<any> & {\n        document: EventTargetLike.Document;\n    };\n\n    export type Document = HasEventTargetAddRemove<any> & {\n        URL: string;\n    };\n\n    export type RxJSSubject<T> = {\n        subscribe: (next: (data: T) => void) => RxJSSubject.Subscription;\n    };\n\n    export namespace RxJSSubject {\n\n        export type Subscription = {\n            unsubscribe(): void;\n        };\n\n        export function match<T>(eventTarget: EventTargetLike<T>): eventTarget is RxJSSubject<T> {\n            return (\n                typeGuard<RxJSSubject<T>>(eventTarget, true) &&\n                eventTarget instanceof Object &&\n                typeof eventTarget.subscribe === \"function\"\n            );\n        }\n\n\n    }\n\n\n    export type NodeStyleEventEmitter =\n        NodeStyleEventEmitter.Compat |\n        NodeStyleEventEmitter.Regular\n        ;\n\n    export namespace NodeStyleEventEmitter {\n\n        export interface Regular {\n            addListener: (eventName: string | symbol, handler: NodeEventHandler) => this;\n            removeListener: (eventName: string | symbol, handler: NodeEventHandler) => this;\n        };\n\n        export interface Compat {\n            addListener: (eventName: string, handler: NodeEventHandler) => void | {};\n            removeListener: (eventName: string, handler: NodeEventHandler) => void | {};\n        }\n\n        export declare type NodeEventHandler = (...args: any[]) => void;\n\n        export function match<T>(eventTarget: EventTargetLike<T>): eventTarget is NodeStyleEventEmitter {\n            return (\n                typeGuard<NodeStyleEventEmitter>(eventTarget, true) &&\n                eventTarget instanceof Object &&\n                typeof eventTarget.addListener === \"function\" &&\n                typeof eventTarget.removeListener === \"function\"\n            );\n        }\n\n    }\n\n    export interface JQueryStyleEventEmitter {\n        on: (eventName: string, handler: Function) => void;\n        off: (eventName: string, handler: Function) => void;\n    }\n\n    export namespace JQueryStyleEventEmitter {\n\n        export function match<T>(eventTarget: EventTargetLike<T>): eventTarget is JQueryStyleEventEmitter {\n            return (\n                typeGuard<JQueryStyleEventEmitter>(eventTarget, true) &&\n                eventTarget instanceof Object &&\n                typeof eventTarget.on === \"function\" &&\n                typeof eventTarget.off === \"function\"\n            );\n        }\n\n    }\n\n    export interface HasEventTargetAddRemove<E> {\n        addEventListener(type: string, listener: ((evt: E) => void) | null, options?: boolean | HasEventTargetAddRemove.Options): void;\n        removeEventListener(type: string, listener?: ((evt: E) => void) | null, options?: HasEventTargetAddRemove.Options | boolean): void;\n    }\n\n    export namespace HasEventTargetAddRemove {\n\n        export interface Options {\n            capture?: boolean;\n            passive?: boolean;\n            once?: boolean;\n        }\n\n        export function match<T>(eventTarget: EventTargetLike<T>): eventTarget is HasEventTargetAddRemove<T> {\n            return (\n                typeGuard<HasEventTargetAddRemove<T>>(eventTarget, true) &&\n                eventTarget instanceof Object &&\n                typeof eventTarget.addEventListener === \"function\" &&\n                typeof eventTarget.removeEventListener === \"function\"\n            );\n        }\n\n    }\n\n\n    /* Return true if o can be a EventTargetLike */\n    export function canBe(o: any): boolean {\n\n        try{\n\n            return (\n                HasEventTargetAddRemove.match(o) ||\n                NodeStyleEventEmitter.match(o) ||\n                JQueryStyleEventEmitter.match(o) ||\n                RxJSSubject.match(o)\n            );\n\n        }catch{\n\n            return false;\n\n        }\n\n    }\n\n\n}\n","\n\nexport class TimeoutEvtError extends Error {\n    constructor(public readonly timeout: number) {\n        super(`Evt timeout after ${timeout}ms`);\n        Object.setPrototypeOf(this, new.target.prototype);\n    }\n}\n\nexport class DetachedEvtError extends Error {\n    constructor() {\n        super(`Evt handler detached`);\n        Object.setPrototypeOf(this, new.target.prototype);\n    }\n}\n\n\n\n","\nimport { typeGuard } from \"tsafe/typeGuard\";\nimport type { NonPostableEvtLike } from \"./NonPostableEvtLike\";\nimport type { Handler } from \"../Handler\";\n\n/** \n * Minimal interface that an object must implement to be a valid context argument \n * ( for interop between mismatching EVT versions )\n * */\nexport interface CtxLike<Result = any> {\n    done(result: Result): void;\n    abort(error: Error): void;\n    zz__addHandler<T>(handler: Handler<T, any, CtxLike<Result>>, evt: NonPostableEvtLike<T>): void;\n    zz__removeHandler<T>(handler: Handler<T, any, CtxLike<Result>>): void;\n}\n\nexport namespace CtxLike {\n\n    export function match<T=any>(o: any): o is CtxLike<T> {\n        return (\n            typeGuard<CtxLike>(o, true) &&\n            o instanceof Object &&\n            typeof o.done === \"function\" &&\n            typeof o.abort === \"function\" &&\n            typeof o.zz__addHandler === \"function\" &&\n            typeof o.zz__removeHandler === \"function\"\n        );\n    }\n\n}\n","import { convertOperatorToStatelessFλ } from \"./convertOperatorToStatelessFLambda\";\nimport { id } from \"tsafe/id\";\nimport type { Operator } from \"../types/Operator\";\n\nfunction f_o_g<A, B, C>(\n    op1: Operator<A, B>,\n    op2: Operator<B, C>\n): Operator.fλ.Stateless<A, C> {\n\n    const opAtoB = convertOperatorToStatelessFλ(op1);\n\n    const opBtoC = convertOperatorToStatelessFλ(op2);\n\n    return id<Operator.fλ.Stateless<A, C>>(\n        (dataA, registerSideEffect) => {\n\n            const resultB = opAtoB(dataA, registerSideEffect);\n\n            if( !resultB ){\n                return null;\n            }\n\n            const [dataB] = resultB;\n\n            const resultC = opBtoC(dataB, registerSideEffect);\n\n            if( !resultC ){\n                return resultC;\n            }\n\n            return [resultC[0]];\n\n        }\n    );\n}\n\n\nexport function compose<A, B, C>(\n    op1: Operator.fλ<A, B>,\n    op2: Operator.fλ<B, C>\n): Operator.fλ.Stateless<A, C>;\nexport function compose<A, B, C extends B>(\n    op1: Operator.fλ<A, B>,\n    op2: (data: B) => data is C,\n): Operator.fλ.Stateless<A, C>;\nexport function compose<A, B>(\n    op1: Operator.fλ<A, B>,\n    op2: (data: B) => boolean,\n): Operator.fλ.Stateless<A, B>;\nexport function compose<A, B extends A, C>(\n    op1: (data: A) => data is B,\n    op2: Operator.fλ<B, C>\n): Operator.fλ.Stateless<A, B>;\nexport function compose<A, B>(\n    op1: (data: A) => boolean,\n    op2: Operator.fλ<A, B>\n): Operator.fλ.Stateless<A, B>;\nexport function compose<A, B extends A, C extends B>(\n    op1: (data: A) => data is B,\n    op2: (data: B) => data is C,\n): Operator.fλ.Stateless<A, C>;\nexport function compose<A, B extends A>(\n    op1: (data: A) => data is B,\n    op2: (data: B) => boolean,\n): Operator.fλ.Stateless<A, B>;\nexport function compose<A, B extends A>(\n    op1: (data: A) => boolean,\n    op2: (data: A) => data is B\n): Operator.fλ.Stateless<A, B>;\nexport function compose<A>(\n    op1: (data: A) => boolean,\n    op2: (data: A) => boolean,\n): Operator.fλ.Stateless<A, A>;\n\n\nexport function compose<A, B, C, D>(\n    op1: Operator.fλ<A, B>,\n    op2: Operator.fλ<B, C>,\n    op3: Operator.fλ<C, D>\n): Operator.fλ.Stateless<A, D>;\n\nexport function compose<A, B, C, D, E>(\n    op1: Operator.fλ<A, B>,\n    op2: Operator.fλ<B, C>,\n    op3: Operator.fλ<C, D>,\n    op4: Operator.fλ<D, E>\n): Operator.fλ.Stateless<A, E>;\n\nexport function compose<A, B, C, D, E>(\n    op1: Operator.fλ<A, B>,\n    op2: Operator.fλ<B, C>,\n    op3: Operator.fλ<C, D>,\n    op4: Operator.fλ<D, E>\n): Operator.fλ.Stateless<A, E>;\n\nexport function compose<A, B, C, D, E, F>(\n    op1: Operator.fλ<A, B>,\n    op2: Operator.fλ<B, C>,\n    op3: Operator.fλ<C, D>,\n    op4: Operator.fλ<D, E>,\n    op5: Operator.fλ<E, F>\n): Operator.fλ.Stateless<A, F>;\n\n\nexport function compose<A, B, C>(\n    op1: Operator<A, B>,\n    op2: Operator<B, C>\n): Operator.fλ.Stateless<A, C>;\n\nexport function compose<A, B, C, D>(\n    op1: Operator<A, B>,\n    op2: Operator<B, C>,\n    op3: Operator<C, D>\n): Operator.fλ.Stateless<A, D>;\n\nexport function compose<A, B, C, D, E>(\n    op1: Operator<A, B>,\n    op2: Operator<B, C>,\n    op3: Operator<C, D>,\n    op4: Operator<D, E>,\n): Operator.fλ.Stateless<A, E>;\n\nexport function compose<A, B, C, D, E, F>(\n    op1: Operator<A, B>,\n    op2: Operator<B, C>,\n    op3: Operator<C, D>,\n    op4: Operator<D, E>,\n    op5: Operator<E, F>\n): Operator.fλ.Stateless<A, F>;\n\n\nexport function compose<T>(\n    ...ops: [\n        Operator<T, any>,\n        ...Operator<any, any>[]\n    ]\n): Operator.fλ.Stateless<T, any>;\n\nexport function compose<T>(\n    ...ops: [\n        Operator<T, any>,\n        ...Operator<any, any>[]\n    ]\n): Operator.fλ.Stateless<T, any>  {\n\n    if (ops.length === 1) {\n\n        const [op] = ops;\n\n        return convertOperatorToStatelessFλ(op);\n\n    }\n\n    const [op1, op2, ...rest] = ops;\n\n    const op1_o_op2 = f_o_g(op1, op2);\n\n    if (rest.length === 0) {\n        return op1_o_op2;\n    }\n\n    return compose(op1_o_op2, ...rest);\n\n\n}\n","\nimport type { Operator } from \"../types/Operator\";\n\nfunction encapsulateOpState<T, U>(\n    statefulFλOp: Operator.fλ.Stateful<T, U>\n): Operator.fλ.Stateless<T, U> {\n\n    let state: U = statefulFλOp[1];\n\n    return (data, registerSideEffect) => {\n\n        const opResult = statefulFλOp[0](data, state, registerSideEffect);\n\n        if (opResult !== null) {\n            registerSideEffect(() => state = opResult[0])\n        }\n\n        return opResult;\n\n    };\n\n}\n\nfunction statelessOpToStatelessFλ<T, U>(op: Operator.Stateless<T, U>): Operator.fλ.Stateless<T, U> {\n    return (data, registerSideEffect) => {\n\n        /* NOTE: Here, if the user is using TypeScript we should have readonly [U] or boolean\n         * but users using vanilla JS can very well provide operators like: text => text.match(/^error/) \n         * and expect things to work event if String.prototype.match returns a RegExpMatch array instead \n         * of boolean. \n         * Long story short we do our best to guess what the user meant with he's operator, if it was\n         * intended to be a filter or a fλ.\n         */\n        const opResult: any = (op as Operator.fλ.Stateless<T, U>)(data, registerSideEffect);\n\n        return (\n            opResult instanceof Object &&\n            !(\"input\" in opResult) && //exclude String.prototype.match\n            opResult.length === 1\n        ) ?\n            opResult\n            :\n            !!opResult ? [data] : null;\n\n    }\n};\n\nexport function convertOperatorToStatelessFλ<T, U>(\n    op: Operator<T, U>\n): Operator.fλ.Stateless<T, U> {\n    return typeof op !== \"function\" ?\n        encapsulateOpState(op) :\n        statelessOpToStatelessFλ(op);\n}\n","/* eslint-disable @typescript-eslint/no-unused-vars */\nimport { overwriteReadonlyProp } from \"./lab/overwriteReadonlyProp\";\nimport { assertIsRefWrapper } from \"./zz_internal/assertIsRefWrapper\";\n\n/** @see <https://docs.tsafe.dev/assert#error-thrown> */\nexport class AssertionError extends Error {\n    constructor(msg: string | undefined) {\n        super(`Wrong assertion encountered` + (!msg ? \"\" : `: \"${msg}\"`));\n\n        Object.setPrototypeOf(this, new.target.prototype);\n\n        if (!this.stack) {\n            return;\n        }\n\n        try {\n            overwriteReadonlyProp(\n                this,\n                \"stack\",\n                this.stack\n                    .split(\"\\n\")\n                    .filter((...[, i]) => i !== 1 && i !== 2)\n                    .join(\"\\n\"),\n            );\n            // eslint-disable-next-line no-empty\n        } catch {}\n    }\n}\n\n/** https://docs.tsafe.dev/assert */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function assert<_T extends true>(condition?: any, msg?: string): asserts condition {\n    if (arguments.length === 0) {\n        condition = true;\n    }\n    if (assertIsRefWrapper.ref !== undefined) {\n        assertIsRefWrapper.ref = undefined;\n        return;\n    }\n\n    if (!condition) {\n        throw new AssertionError(msg);\n    }\n}\n","/** https://docs.tsafe.dev/id  */\nexport const id = <T>(x: T) => x;\n\n/**\n * Ensure that a that a specific type that we are declaring extends a more generic type\n *\n * Use case example 1:\n *\n * type MyObject = {\n *     p1: string;\n *     p2: string;\n *     a: string;\n *     b: string;\n * };\n *\n * We want to define a type that consist in an union of\n * all the property name that are letters:\n *\n * type AlphabeticalKeys = Id<keyof MyObject, \"a\" | \"b\">;\n *\n * Here AlphabeticalKeys is \"a\" | \"b\" but it's better than\n * simply writing it explicitly as we get autocompletion\n * and we can't include a property name that does not exist on MyObject.\n *\n * Use case example 2:\n *\n * We want to declare object type that only take string or number\n * as key value:\n *\n * export type MyObject = Id<Record<string, string | number>, {\n *     p1: string;\n *     p2: number;\n * }>;\n *\n * If later on someone adds \"p3\": string[] he will get a type error.\n * */\nexport type Id<Generic, Specific extends Generic> = Specific;\n","/* eslint-disable @typescript-eslint/no-namespace */\n/* eslint-disable @typescript-eslint/no-explicit-any */\n\nimport { assertIsRefWrapper } from \"./zz_internal/assertIsRefWrapper\";\n\nconst errorMessage = [\n    `Wrong usage of the ${is.name} function refer to`,\n    `https://docs.tsafe.dev/${is.name.toLowerCase()}`,\n].join(\" \");\n\nexport function is<T>(_value: any): _value is T {\n    const ref = {};\n\n    if (assertIsRefWrapper.ref !== undefined) {\n        assertIsRefWrapper.ref = undefined;\n        throw new Error(errorMessage);\n    }\n\n    assertIsRefWrapper.ref = ref;\n\n    Promise.resolve().then(() => {\n        if (assertIsRefWrapper.ref === ref) {\n            throw new Error(errorMessage);\n        }\n    });\n\n    return null as any;\n}\n","// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function isPromiseLike<T = void>(o: any): o is PromiseLike<T> {\n    return typeof o?.then === \"function\";\n}\n","/* eslint-disable no-empty */\n/* eslint-disable @typescript-eslint/no-explicit-any */\nimport { assert } from \"../assert\";\nimport { is } from \"../is\";\n\n/**\n * Assign a value to a property even if the object is freezed or if the property is not writable\n * Throw if the assignation fail ( for example if the property is non configurable write: false )\n * */\nexport const overwriteReadonlyProp = <T extends { [key: string]: any }, K extends keyof T>(\n    obj: T,\n    propertyName: K,\n    value: T[K],\n): T[K] => {\n    try {\n        obj[propertyName] = value;\n    } catch {}\n\n    if (obj[propertyName] === value) {\n        return value;\n    }\n\n    let errorDefineProperty: Error | undefined = undefined;\n\n    const propertyDescriptor: PropertyDescriptor = Object.getOwnPropertyDescriptor(\n        obj,\n        propertyName,\n    ) || {\n        \"enumerable\": true,\n        \"configurable\": true,\n    };\n\n    if (!!propertyDescriptor.get) {\n        throw new Error(`Probably a wrong ides to overwrite ${String(propertyName)} getter`);\n    }\n\n    try {\n        Object.defineProperty(obj, propertyName, {\n            ...propertyDescriptor,\n            value,\n        });\n    } catch (error) {\n        assert(is<Error>(error));\n        errorDefineProperty = error;\n    }\n\n    if (obj[propertyName] !== value) {\n        throw errorDefineProperty || new Error(\"Can't assign\");\n    }\n\n    return value;\n};\n","/* eslint-disable @typescript-eslint/no-namespace */\n/* eslint-disable @typescript-eslint/no-explicit-any */\n\n/** https://docs.tsafe.dev/typeguard */\nexport function typeGuard<T>(_value: any, isMatched: boolean): _value is T {\n    return isMatched;\n}\n","import { id } from \"../id\";\n\nexport const assertIsRefWrapper = {\n    \"ref\": id<undefined | Record<string, never>>(undefined),\n};\n","\nimport { overwriteReadonlyProp } from \"tsafe/lab/overwriteReadonlyProp\";\n\nexport class Deferred<T> {\n\n    public readonly pr: Promise<T>;\n\n    /** NOTE: Does not need to be called bound to instance*/\n    public readonly resolve: (value: T)=> void;\n    public readonly reject: (error: any)=> void;\n\n    constructor() {\n\n        let resolve!: (value: T)=> void;\n        let reject!: (error: any)=> void;\n\n        this.pr = new Promise<T>(\n            (resolve_, reject_) => {\n\n                resolve = value => {\n\n                    overwriteReadonlyProp(this, \"isPending\", false);\n                    resolve_(value);\n\n                };\n\n                reject = error => {\n\n\n                    overwriteReadonlyProp(this, \"isPending\", false);\n                    reject_(error);\n\n                };\n\n            }\n        );\n\n        this.resolve = resolve;\n        this.reject = reject;\n\n    }\n\n\n    public readonly isPending: boolean = true;\n\n\n}\n\nexport namespace Deferred {\n\n    export type Unpack<T extends Deferred<any>> = T extends Deferred<infer U> ? U : never;\n\n}\n\nexport class VoidDeferred extends Deferred<undefined>{\n\n    declare public readonly resolve: () => void;\n\n}\n\n\n\n\n\n\n\n","\n//NOTE: Deno can't use NodeJS type def ( obviously )\nexport type Timer= { _timerBrand: any; };\nexport const safeSetTimeout = (callback: () => void, ms: number): Timer => setTimeout(callback, ms) as any;\nexport const safeClearTimeout = (timer: Timer): void => clearTimeout(timer as any);","import objectWithoutPropertiesLoose from \"./objectWithoutPropertiesLoose.js\";\nexport default function _objectWithoutProperties(source, excluded) {\n  if (source == null) return {};\n  var target = objectWithoutPropertiesLoose(source, excluded);\n  var key, i;\n\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n\n    for (i = 0; i < sourceSymbolKeys.length; i++) {\n      key = sourceSymbolKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n      target[key] = source[key];\n    }\n  }\n\n  return target;\n}","export default function _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}"],"names":["Object","enumerable","get","useRerenderOnStateChange","useEffect","exports","effect","deps","ctx","Evt_2","newCtx","done","useState","evt","setState","state","useEvt","attach","asyncOp","out","importProxy_1","Evt","create","undefined","currentCallCount","data","thisCallCount","prOpResult","opResult","_a","post","args","length","StatefulEvt","EventTargetLikeAsValue","fromImplForTargetEventLike","target","eventName","options","target_","proxy","canBe","evt_1","isCtxDone_1","getEvtDonePostCount","evtDoneOrAborted","postCount","n","then","mergeImpl","Array","from","map","HasEventTargetAddRemove","match","listener","addEventListener","removeEventListener","NodeStyleEventEmitter","addListener","removeListener","JQueryStyleEventEmitter","on","off","RxJSSubject","subscription_1","subscribe","unsubscribe","id","assert","attachOnce","fromImplForObserver","ObserverConstructor","observer","entry","_b","observe","disconnect","ctxOrTargetOrObserverConstructor","targetOrEventNameOrObserverConstructorOrObserverTarget","eventNameOrOptionsOrObserverTarget","typeGuard","ctxByObj","WeakMap_1","obj","Ctx","set","require","runSideEffect","sideEffect","CtxLikeAsValue","nsCtxLike","lazyEvtAttach","LazyEvt_1","lazyEvtDetach","__maxHandlers","traceId","handlers","handlerTriggers","Map_1","__currentChronologyMark","asyncHandlerCount","EvtImpl","this","__defaultMaxHandlers","isFinite","p1","p2","isP1Ctx","initialValue","callback","params","formatter","log","traceFormatter","JSON","stringify","inputs","console","apply","__spreadArray","_d","op","invocableOp","invocableOpByOp","Error","join","handler","wTimer","rejectPr","index","indexOf","zz__removeHandler","splice","async","delete","safeClearTimeout","EvtError_1","resolvePr","once","detach","transformedData","prOrValue","call","isPromiseLike","propsFromArgs","propsFromMethodName","d","Deferred_1","detachHandler","reject","pr","timeout","safeSetTimeout","handlerTrigger","triggerHandler","isPending","resolve","asyncHandlerChronologyMark","getChronologyMark","prepend","i","extract","push","checkForPotentialMemoryLeak","zz__addHandler","onAddHandlerByEvt","has","maxHandlers","message","concat","getHandlers","Evt_parsePropsFromArgs_1","toString","keys","key","forEach","str","warn","hasSideEffect","getInvocableOp","isExtracted","find","_this_1","isHandledByOp","handlerCount","filter","prAllHandlerCallbacksResolved","getReturnValue","Promise","all","_c","prOrUndefined","runExclusive","buildMethodCb","postChronologyMark","releaseLock","chronologyMarkStartResolveTick","promises","handlerMark","exceptionRange","asyncHandlerChronologyExceptionRange","lowerMark","upperMark","promise","catch","handlersDump","detachedHandlers","evtDelegate","addHandler","__assign","parsePropsFromArgs","propsFormMethodNames","waitFor","Symbol","asyncIterator","iter","props","self","previousDonePostCount","timerWrap","setTimeoutCallback","error","abort","timer","setTimeout","evtProxy","pipe","registerSideEffect","clearTimeout","events","event","type","timer_1","next","eventWrap","shift","dEventWrap_1","ctx2_1","attachOnceExtract","return","__attachX","attachExtract","attachPrepend","attachOncePrepend","methodName","isHandled","evtAttach","wait","trace","overwriteReadonlyProp","postSync","postAsync","postAsyncFactory","postOrPostAndWait","Evt_create_1","Evt_newCtx_1","Evt_merge_1","Evt_from_1","getCtxFactory","Evt_loosenType_1","Evt_factorize_1","Evt_asPostable_1","Evt_asyncPipe_1","Evt_asNonPostable_1","evts","evtUnion","matchAll","canBeOperator","p","defaultParams","getOpWrap","ops","compose_1","rest","value","p3","p4","initialPostCount","LazyEvt","__evt","doWait","__post","EventTargetLike","eventTarget","o","_super","setPrototypeOf","_newTarget","prototype","__extends","CtxLike","f_o_g","op1","op2","opAtoB","opBtoC","dataA","resultB","dataB","resultC","compose","op1_o_op2","__read","statefulFλOp","encapsulateOpState","statelessOpToStatelessFλ","msg","_this","stack","split","condition","arguments","assertIsRefWrapper_1","ref","AssertionError","x","errorMessage","is","name","toLowerCase","_value","propertyName","errorDefineProperty","propertyDescriptor","getOwnPropertyDescriptor","String","defineProperty","isMatched","resolve_","reject_","Deferred","ms","_objectWithoutProperties","source","excluded","sourceKeys","getOwnPropertySymbols","sourceSymbolKeys","propertyIsEnumerable"],"sourceRoot":""}